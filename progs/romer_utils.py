# romer_utils: utilities for the Romer project
# amoreira@ubi.pt, ljmamoreira@gmail.com
# November 2024

import os
import datetime as dttm
import numpy as np
import scipy.interpolate as intrp
import matplotlib.pyplot as plt
import requests
from bisect import bisect_left


# Physical constants
T = dttm.timedelta(seconds=152853.5047) # Io's orbital period in secs
AU = 149597870700
C = 299792458

# Special dates for the synodic period of 2025
OPPO = dttm.datetime(2024, 12,  7, 20, 51,  0)
QREG = dttm.datetime(2025,  3,  2, 18, 13, 13)
CONJ = dttm.datetime(2025,  6, 24, 15, 20, 30)
QAPR = dttm.datetime(2025, 10, 17,  5, 30, 31)

# Magnitude curves directories
MCEMDIR = "../data/magc/emergences/"
MCOCDIR = "../data/magc/occultations/"


# Available emergence (regression) dates for the synodic year
EDATES = sorted([
    dttm.date.fromisoformat(fname[2:-4])
    for fname in os.listdir(MCEMDIR)
    ])


# Available occultation (approximation) dates for the synodic year
ODATES = sorted([
    dttm.date.fromisoformat(fname[2:-4])
    for fname in os.listdir(MCOCDIR)
    ])


class Event(object):
    def __init__(self, kind, time, distance):
        self.kind = kind     # 'e' or 'o'
        self.t = time
        self.d = distance

    def __repr__(self):
        if self.kind == 'e':
            mystr = "Emergence ("
        else:
            mystr = "Occultation ("
        mystr +=  str(self.t)+"; "+str(self.d)+')'
        return mystr

    def __str__(self):
        return self.__repr__()


def read_mcfile(filename):
   """
   read_file(filename): reads magcurve file, returns array with time, magnitude,
   distance to Jupiter.
   time as datetime.datetime object, magnitude and distance as float, distance
   expressed in AU.
   """
   with open(filename) as file:
       txt = file.read()
   txt = txt.strip()
   datalines = txt.split('\n')
   data = []
   for line in datalines:
       items = line.split()
       time = dttm.datetime.strptime(items[0], "%Y-%m-%dT%H:%M:%S")
       vmag = float(items[1])
       dist = float(items[2])
       data.append([time, vmag, dist])
   data = np.array(data)
   #Clean data of repeated times generated by stellarium rounding core.getDate
   for i in range(len(data) - 1, 0, -1):
       if data[i, 0] == data[i-1, 0]:
           m = (data[i,1] + data[i-1,1])/2
           d = (data[i,2] + data[i-1,2])/2
           data[i-1,1] = m
           data[i-1,2] = d    
           data = np.delete(data,i,0)
   return np.array(data)


def dttm2tsecs(timearray, tref=None):
    """
    dttm2secs(timearray,tref=None): convert array of datetime.datetime objects
    in array of seconds after tref
    timearray: array of datetime.datetime objects
    tref: datetime.datetime object. If None, use first element in timearray.
    """
    if tref:
        t0 = tref
    else:
        t0 = timearray[0]
    return np.array([(tt - t0).total_seconds() for tt in timearray])
    

def get_ctd(data):
    """
    get_ctd(ocurdata): return time and distance to jupiter from magnitude curve 
        stored in data
    data: array with shape (N,3) storing time (as datetime), magnitude and 
        distance to jupiter (in AU),
    """
    time_dtt, mag, dist = data.T
    tsecs = dttm2tsecs(time_dtt)
    cmag = (mag[0] + mag[-1]) / 2
    ct = intrp.Akima1DInterpolator(tsecs, mag-cmag).roots()[0]
    ctime = time_dtt[0] + dttm.timedelta(seconds=ct)
    cdist = float(intrp.InterpolatedUnivariateSpline(tsecs, dist)(ct))
    return ctime, cdist


def load_all(folder):
    """
    load_all(foldername): reads all magcurve files in folder, returns a list of
        times (in seconds) for each occurrence and corresponding list of
        distances to Jupiter.
    """
    tdist = []
    file_list = sorted(os.listdir(folder))
    for filename in file_list:
        data = read_mcfile(folder + '/' + filename)
        tdist.append(get_ctd(data))
    return tdist


EMERGS = [Event('e', l[0], l[1])
            for l in load_all(MCEMDIR)]
OCCULS = [Event('o', l[0], l[1])
            for l in load_all(MCOCDIR)]


def get_date_cbracket(dl, cd, n):
    """
    get_date_cbracket(dl, cd, n): return initial and final dates for n
    revolutions of Io from a date list dl, centered on date cd (datetime)
    """
    cpos = bisect_left(dl, cd.date())
    spos = int(cpos - n/2)
    if spos < 0:
        raise IndexError('get_dates: no dates. n='+str(n)+'; cd='+str(cd))
    fpos = int(cpos + n/2)
    if fpos > len(dl):
        raise IndexError('get_dates: no dates. n='+str(n)+'; cd='+str(cd))
    return dl[spos], dl[fpos-1]


def event_of_date(date, evlist):
    for event in evlist:
        if event.t.date() == date:
            return event
    else:
        raise IndexError("No events match date "+str(date))


def get_quartet_by_dates(d1, d2, n, set1=EMERGS, set2=OCCULS):
    """
    get_quartet_by_dates(d1, d2, n, [set1], [set2]): return 2 pairs of Io events
    spanning n orbits each, starting at dates d1 and d2, selected from sets set1
    and set2.
    """
    ev1 = event_of_date(d1, set1)
    ev2 = event_of_date(d2, set2)
    i1 = set_a.index(ev1)
    i2 = set_b.index(ev2)
    ev3 = set_a[i1+n]
    ev4 = set_b[i2+n]
    return (ev1, ev3), (ev2, ev4)


def get_quartet_ends(e_ai, e_bi, n, set_a=EMERGS, set_b=OCCULS):
    """
    get_quartet_by_events(e_ai, e_bi, n, [set_a], [set_b]): return final events
    of intervals spanning n orbits each, starting at events e_ai and e_bi,
    selected from sets set_a and set_b.
    """
    i_a = set_a.index(e_ai)
    i_b = set_b.index(e_bi)
    e_af = set_a[i_a + n]
    e_bf = set_b[i_b + n]
    return e_af, e_bf


def c_by_quartet(e1, e2, e3, e4):
    if int(((e2.t-e1.t)-(e4.t-e3.t))/T)!=0:
        raise ValueError("quartet_c: unequal number of orbits in the two intervals")
    dda = e2.d - e1.d
    ddr = e4.d - e3.d
    dta = (e2.t - e1.t).total_seconds()
    dtr = (e4.t - e3.t).total_seconds()
    return (ddr - dda) / (dtr - dta)


def c_simple(e1,e2,e3,e4):
    d_t = ((e2.t-e1.t)-(e4.t-e3.t))/T
    if int(d_t) != 0:
        msg = "c_simple: unequal number of orbits in the two intervals "
        msg += "(d_t = {:4})".format(d_t)
        raise ValueError(msg)
    dd =  AU * ((e2.d - e1.d) - (e4.d - e3.d))
    dt = ((e2.t - e1.t) - (e4.t - e3.t)).total_seconds()
    return dd / dt


def check_magcurve(magcfile):
    """
    check_magcurvefille(filenale): read and process data from file filename and
    plots the magnitude curve.
    show_cdata: boolean. If True, display info for central magnitude on the plot
    """
    data = read_file(magcfile)
    time, mag, dist= data.T
    t = dttm2tsecs(time)
    plt.plot(t,mag)
    ct, cdist = get_ctd(data)
    ctsecs = (ct-time[0]).total_seconds()
    plt.vlines(ctsecs,8,16)
    print("ct=",ct)
    print("cd=",cdist,"AU")


def hrz_get_ephem(start_time, stop_time, step_size):
    with open("hrz_script_template.txt", 'r') as file:
        script_lines = file.readlines()
    script_lines[-3] = script_lines[-3][:11] + "'" + str(start_time) + "'\n"
    script_lines[-2] = script_lines[-2][:10] + "'" + str(stop_time) + "'\n"
    script_lines[-1] = script_lines[-1][:10] + "'" + str(step_size) + "'\n"
    with open("horizons_script.txt", 'w') as file:
        file.writelines(script_lines)
    with open("horizons_script.txt") as script:
        url = 'https://ssd.jpl.nasa.gov/api/horizons_file.api'
        r = requests.post(url, data={'format':'text'}, files={'input': script})
    return r.text

def hrz_tstamp2dttm(tstamp):
    tspl = tstamp.split('.')
    datehour = tspl[0]
    if len(tspl)>1:
        microsecs = tspl[1]
    else:
        microsecs = 0
    try:
        t = dttm.datetime.strptime(datehour,"%Y-%b-%d %H:%M:%S")
    except ValueError:
        t = dttm.datetime.strptime(datehour,"%Y-%m-%d %H:%M:%S")
    t += dttm.timedelta(microseconds=int("{:06}".format(microsecs)))
    return t

def hrz_get_ctd(ephem_text):
    # Split the ephemerides text and discard header and footer
    etls = ephem_text.split('\n')
    ephem = etls[etls.index('$$SOE')+1: etls.index('$$EOE')]
    # Find lines of start and finish of partial imersion in Jupiter's shadow
    strt_line = next(l for l in ephem if "/P" in l.upper())
    stop_line = next(l for l in ephem[::-1] if "/P" in l.upper())
    part_ephem = ephem[ephem.index(strt_line): ephem.index(stop_line)+1]
    # Get the time and distance at middle occultation
    tdtm = [hrz_tstamp2dttm(line[1:25]) for line in part_ephem]
    ct = tdtm[0] + (tdtm[-1] - tdtm[0]) / 2
    tsecs = np.array([(t-tdtm[0]).total_seconds() for t in tdtm])
    d = np.array([float(line.split()[-1]) for line in part_ephem])
    cd = intrp.Akima1DInterpolator(tsecs, d)((ct-tdtm[0]).total_seconds())
    return ct, cd
